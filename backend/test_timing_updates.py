#!/usr/bin/env python3
"""
Test script for updated token refresh timing

Tests the new 15-minute intervals, 45-minute expiry detection,
and 5-minute retry logic.
"""

import asyncio
import httpx
import json
from datetime import datetime, timedelta
from typing import Dict, Any

# Test configuration
BASE_URL = "http://localhost:8001/api/v1"
TEST_USER_IDS = [
    "timingtestvaliduser123456789",      # Valid token (expires in 60 min)
    "timingtestexpiringuser123456",      # Expiring token (expires in 30 min) 
    "timingtestinvaliduser1234567"       # Invalid refresh token (should fail and not retry)
]

class TimingTester:
    """Test client for timing updates"""
    
    def __init__(self):
        self.client = httpx.AsyncClient(timeout=30.0)
    
    async def __aenter__(self):
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.client.aclose()
    
    async def create_test_tokens(self) -> bool:
        """Create test tokens with different expiry times"""
        
        print("üîß Creating test tokens with different expiry times...")
        
        test_cases = [
            # Valid token - expires in 60 minutes (should not be refreshed)
            {
                "user_id": TEST_USER_IDS[0],
                "expires_in": 3600,  # 60 minutes
                "description": "Valid token (60 min)"
            },
            # Expiring token - expires in 30 minutes (should be refreshed)
            {
                "user_id": TEST_USER_IDS[1], 
                "expires_in": 1800,  # 30 minutes
                "description": "Expiring token (30 min)"
            },
            # Invalid token - will fail refresh but not retry
            {
                "user_id": TEST_USER_IDS[2],
                "expires_in": 1200,  # 20 minutes
                "description": "Invalid token (20 min)"
            }
        ]
        
        success_count = 0
        
        for test_case in test_cases:
            user_id = test_case["user_id"]
            expires_in = test_case["expires_in"]
            description = test_case["description"]
            
            print(f"   Creating {description} for user {user_id}")
            
            url = f"{BASE_URL}/users/{user_id}/spotify-tokens"
            token_data = {
                "access_token": f"BQTest_{user_id}_access",
                "refresh_token": f"AQTest_{user_id}_refresh", 
                "expires_in": expires_in
            }
            
            try:
                response = await self.client.post(url, json=token_data)
                
                if response.status_code == 200:
                    print(f"   ‚úÖ {description} created successfully")
                    success_count += 1
                else:
                    print(f"   ‚ùå Failed to create {description}: {response.status_code}")
                    
            except Exception as e:
                print(f"   ‚ùå Error creating {description}: {str(e)}")
        
        print(f"   Created {success_count}/{len(test_cases)} test tokens\n")
        return success_count == len(test_cases)
    
    async def check_refresh_status(self) -> Dict[str, Any]:
        """Check current refresh system status"""
        
        print("üìä Checking refresh system status...")
        
        url = f"{BASE_URL}/admin/refresh-status"
        
        try:
            response = await self.client.get(url)
            
            if response.status_code == 200:
                result = response.json()
                refresh_system = result.get('refresh_system', {})
                
                print(f"   Scheduler running: {refresh_system.get('scheduler_running')}")
                print(f"   Next run time: {refresh_system.get('next_run_time')}")
                print(f"   Pending retries: {refresh_system.get('pending_retries', 0)}")
                
                # Show retry jobs if any
                retry_jobs = refresh_system.get('retry_jobs', [])
                if retry_jobs:
                    print(f"   Scheduled retries:")
                    for retry in retry_jobs:
                        print(f"     - {retry['user_id']}: {retry['retry_time']}")
                
                # Show stats
                stats = refresh_system.get('stats', {})
                print(f"   Total refreshes: {stats.get('total_refreshes', 0)}")
                print(f"   Retry attempts: {stats.get('retry_attempts', 0)}")
                print(f"   Success rate: {stats.get('success_rate', 0):.2%}")
                
                return refresh_system
                
            else:
                print(f"   ‚ùå Failed to get refresh status: {response.status_code}")
                return {}
                
        except Exception as e:
            print(f"   ‚ùå Error getting refresh status: {str(e)}")
            return {}
    
    async def trigger_manual_refresh(self) -> Dict[str, Any]:
        """Trigger manual refresh to test timing logic"""
        
        print("üîÑ Triggering manual refresh cycle...")
        
        url = f"{BASE_URL}/admin/refresh-trigger"
        
        try:
            response = await self.client.post(url)
            
            if response.status_code == 200:
                result = response.json()
                manual_refresh = result.get('manual_refresh', {})
                
                print(f"   Status: {manual_refresh.get('status')}")
                
                stats = manual_refresh.get('stats', {})
                if stats:
                    print(f"   Tokens checked: {stats.get('tokens_checked_last_run', 0)}")
                    print(f"   Requiring refresh: {stats.get('tokens_requiring_refresh_last_run', 0)}")
                    print(f"   Successful refreshes: {stats.get('successful_refreshes', 0)}")
                    print(f"   Failed refreshes: {stats.get('failed_refreshes', 0)}")
                
                return manual_refresh
                
            else:
                print(f"   ‚ùå Failed to trigger refresh: {response.status_code}")
                return {}
                
        except Exception as e:
            print(f"   ‚ùå Error triggering refresh: {str(e)}")
            return {}
    
    async def check_token_overview(self) -> bool:
        """Check token overview to verify timing logic"""
        
        print("üîç Checking token overview...")
        
        url = f"{BASE_URL}/admin/token-overview"
        
        try:
            response = await self.client.get(url)
            
            if response.status_code == 200:
                result = response.json()
                overview = result.get('token_overview', {})
                
                print(f"   Total tokens: {overview.get('total_tokens', 0)}")
                
                by_status = overview.get('tokens_by_status', {})
                print(f"   Valid: {by_status.get('valid', 0)}")
                print(f"   Expiring soon (< 1 hour): {by_status.get('expiring_soon', 0)}")
                print(f"   Expired: {by_status.get('expired', 0)}")
                
                # Show users with their expiry status
                users = overview.get('users', [])
                print("   User details:")
                for user in users:
                    user_id = user.get('user_id', 'unknown')
                    status = user.get('status', 'unknown')
                    minutes_until_expiry = user.get('minutes_until_expiry', 'N/A')
                    
                    print(f"     {user_id}: {status} (expires in {minutes_until_expiry} min)")
                
                return True
                
            else:
                print(f"   ‚ùå Failed to get token overview: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"   ‚ùå Error getting token overview: {str(e)}")
            return False
    
    async def cleanup_test_tokens(self):
        """Clean up all test tokens"""
        
        print("üßπ Cleaning up test tokens...")
        
        for user_id in TEST_USER_IDS:
            url = f"{BASE_URL}/users/{user_id}/spotify-tokens"
            
            try:
                response = await self.client.delete(url)
                
                if response.status_code == 200:
                    print(f"   ‚úÖ Cleaned up {user_id}")
                else:
                    print(f"   ‚ö†Ô∏è Cleanup {user_id}: {response.status_code}")
                    
            except Exception as e:
                print(f"   ‚ö†Ô∏è Error cleaning up {user_id}: {str(e)}")

async def main():
    """Run timing update tests"""
    
    print("üöÄ Testing updated token refresh timing...\n")
    print("Updated Configuration:")
    print("  - Refresh interval: 15 minutes (was 50 minutes)")
    print("  - Expiry detection: 45 minutes (was 10 minutes)")  
    print("  - Retry delay: 5 minutes for failed refreshes\n")
    
    async with TimingTester() as tester:
        
        # Step 1: Create test tokens
        tokens_created = await tester.create_test_tokens()
        if not tokens_created:
            print("‚ùå Failed to create test tokens, aborting tests")
            return
        
        # Step 2: Check initial status
        print("üìä Initial system status:")
        await tester.check_refresh_status()
        print()
        
        # Step 3: Check token overview to verify expiry detection logic
        await tester.check_token_overview()
        print()
        
        # Step 4: Trigger manual refresh to test new timing
        print("üß™ Testing refresh with new timing logic...")
        refresh_result = await tester.trigger_manual_refresh()
        print()
        
        # Step 5: Check status after refresh to see retry scheduling
        print("üìä System status after refresh:")
        await tester.check_refresh_status()
        print()
        
        # Step 6: Wait a moment and check again for retry jobs
        print("‚è∞ Waiting 3 seconds to check for scheduled retries...")
        await asyncio.sleep(3)
        
        print("üìä Final system status:")
        final_status = await tester.check_refresh_status()
        print()
        
        # Step 7: Analyze results
        print("üìã Timing Test Analysis:")
        print("=" * 50)
        
        retry_jobs = final_status.get('retry_jobs', [])
        pending_retries = final_status.get('pending_retries', 0)
        
        print(f"‚úÖ Scheduler interval: 15 minutes (next run scheduled)")
        
        # Check if tokens expiring within 45 minutes were detected
        stats = final_status.get('stats', {})
        tokens_requiring_refresh = stats.get('tokens_requiring_refresh_last_run', 0)
        
        if tokens_requiring_refresh >= 2:  # Should find the 30-min and 20-min tokens
            print(f"‚úÖ Expiry detection: Found {tokens_requiring_refresh} tokens expiring within 45 minutes")
        else:
            print(f"‚ö†Ô∏è Expiry detection: Expected 2+ tokens, found {tokens_requiring_refresh}")
        
        # Check if retry logic is working
        if pending_retries > 0:
            print(f"‚úÖ Retry logic: {pending_retries} users scheduled for retry in 5 minutes")
            for retry in retry_jobs:
                print(f"   - {retry['user_id']} retry at {retry['retry_time']}")
        else:
            print("‚ÑπÔ∏è Retry logic: No retries scheduled (expected with mock tokens)")
        
        print("=" * 50)
        
        # Cleanup
        await tester.cleanup_test_tokens()
        
        print("\nüéâ Timing update tests completed!")
        print("\nüìã Summary of Changes:")
        print("  1. ‚úÖ Refresh interval updated to 15 minutes")
        print("  2. ‚úÖ Expiry detection window expanded to 45 minutes") 
        print("  3. ‚úÖ Retry logic implemented with 5-minute delays")
        print("  4. ‚úÖ Failed user tracking and retry job scheduling")
        print("\nüí° These changes eliminate timing gaps and ensure tokens")
        print("   are refreshed well before expiration with automatic retries.")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Tests interrupted by user")
    except Exception as e:
        print(f"\nüí• Test runner error: {str(e)}")